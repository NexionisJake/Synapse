<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serendipity Accessibility Compliance Tests</title>
    <link rel="stylesheet" href="static/css/style.css">
    <style>
        .accessibility-test-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
        }
        .test-result {
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid;
        }
        .test-pass {
            background-color: #e8f5e8;
            border-left-color: #4caf50;
            color: #2e7d32;
        }
        .test-fail {
            background-color: #ffebee;
            border-left-color: #f44336;
            color: #c62828;
        }
        .test-warn {
            background-color: #fff8e1;
            border-left-color: #ff9800;
            color: #ef6c00;
        }
        .wcag-level {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 8px;
        }
        .wcag-a { background: #e3f2fd; color: #1976d2; }
        .wcag-aa { background: #f3e5f5; color: #7b1fa2; }
        .wcag-aaa { background: #e8f5e8; color: #388e3c; }
        .compliance-score {
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .score-excellent { background: #e8f5e8; color: #2e7d32; }
        .score-good { background: #fff8e1; color: #ef6c00; }
        .score-poor { background: #ffebee; color: #c62828; }
        .keyboard-test-area {
            border: 2px dashed #ccc;
            padding: 20px;
            margin: 15px 0;
            background: #f9f9f9;
        }
        .focus-indicator {
            outline: 3px solid #2196f3;
            outline-offset: 2px;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div class="accessibility-test-container">
        <header>
            <h1>‚ôø Serendipity Accessibility Compliance Tests</h1>
            <p>Comprehensive WCAG 2.1 compliance testing for serendipity analysis features</p>
        </header>

        <div id="compliance-score" class="compliance-score">
            <div>Overall Compliance Score</div>
            <div id="score-value">Calculating...</div>
        </div>

        <section class="test-section">
            <h2>üéØ WCAG 2.1 Level A Compliance</h2>
            <div id="wcag-a-results"></div>
        </section>

        <section class="test-section">
            <h2>üéØ WCAG 2.1 Level AA Compliance</h2>
            <div id="wcag-aa-results"></div>
        </section>

        <section class="test-section">
            <h2>üéØ WCAG 2.1 Level AAA Compliance</h2>
            <div id="wcag-aaa-results"></div>
        </section>

        <section class="test-section">
            <h2>‚å®Ô∏è Keyboard Navigation Tests</h2>
            <div class="keyboard-test-area">
                <p>Use Tab, Shift+Tab, Enter, and Space to navigate these test elements:</p>
                <button id="test-button-1" type="button">Test Button 1</button>
                <button id="test-button-2" type="button">Test Button 2</button>
                <a href="#test-link" id="test-link">Test Link</a>
                <input type="text" id="test-input" placeholder="Test Input" aria-label="Test input field">
                <select id="test-select" aria-label="Test select dropdown">
                    <option>Option 1</option>
                    <option>Option 2</option>
                </select>
            </div>
            <div id="keyboard-results"></div>
        </section>

        <section class="test-section">
            <h2>üîä Screen Reader Tests</h2>
            <div id="screen-reader-results"></div>
        </section>

        <section class="test-section">
            <h2>üé® Color and Contrast Tests</h2>
            <div id="color-contrast-results"></div>
        </section>

        <!-- Live Serendipity Components for Testing -->
        <section class="test-section">
            <h2>üß™ Live Serendipity Component Tests</h2>
            <div class="serendipity-section" role="region" aria-labelledby="serendipity-heading">
                <h3 id="serendipity-heading">Serendipity Analysis</h3>
                
                <button id="discover-connections-btn" type="button" 
                        aria-describedby="serendipity-description"
                        aria-expanded="false">
                    <span class="button-icon" aria-hidden="true">üîç</span>
                    <span class="button-text">Discover Connections</span>
                </button>
                
                <div id="serendipity-description" class="sr-only">
                    Analyze your thoughts and conversations to discover hidden connections and patterns
                </div>
                
                <div id="serendipity-status" aria-live="polite" aria-atomic="true" class="ready">
                    <span class="status-text">Ready to analyze</span>
                </div>
                
                <div id="serendipity-results" 
                     aria-live="polite" 
                     aria-atomic="false"
                     role="region" 
                     aria-label="Analysis results"
                     aria-describedby="results-description">
                </div>
                
                <div id="results-description" class="sr-only">
                    This area will display discovered connections and patterns from your analysis
                </div>
            </div>
            <div id="component-results"></div>
        </section>

        <section class="test-section">
            <h2>üìä Accessibility Audit Summary</h2>
            <div id="audit-summary"></div>
        </section>
    </div>

    <script src="static/js/dashboard.js"></script>
    <script>
        class AccessibilityComplianceTester {
            constructor() {
                this.results = {
                    wcag_a: [],
                    wcag_aa: [],
                    wcag_aaa: [],
                    keyboard: [],
                    screen_reader: [],
                    color_contrast: [],
                    components: []
                };
                this.totalTests = 0;
                this.passedTests = 0;
            }

            async runAllTests() {
                console.log('‚ôø Starting Accessibility Compliance Tests...');
                
                await this.testWCAG_A_Compliance();
                await this.testWCAG_AA_Compliance();
                await this.testWCAG_AAA_Compliance();
                await this.testKeyboardNavigation();
                await this.testScreenReaderSupport();
                await this.testColorContrast();
                await this.testSerendipityComponents();
                
                this.displayResults();
                this.generateAuditSummary();
                
                console.log('‚úÖ Accessibility Compliance Tests Complete');
            }

            async testWCAG_A_Compliance() {
                console.log('Testing WCAG 2.1 Level A compliance...');

                const tests = [
                    {
                        name: '1.1.1 Non-text Content',
                        test: () => this.testNonTextContent(),
                        guideline: 'All images have alt text or are marked decorative'
                    },
                    {
                        name: '1.3.1 Info and Relationships',
                        test: () => this.testInfoAndRelationships(),
                        guideline: 'Information and relationships are programmatically determinable'
                    },
                    {
                        name: '1.3.2 Meaningful Sequence',
                        test: () => this.testMeaningfulSequence(),
                        guideline: 'Content has a logical reading order'
                    },
                    {
                        name: '1.4.1 Use of Color',
                        test: () => this.testUseOfColor(),
                        guideline: 'Color is not the only means of conveying information'
                    },
                    {
                        name: '2.1.1 Keyboard',
                        test: () => this.testKeyboardAccess(),
                        guideline: 'All functionality is available via keyboard'
                    },
                    {
                        name: '2.1.2 No Keyboard Trap',
                        test: () => this.testNoKeyboardTrap(),
                        guideline: 'Keyboard focus can move away from any component'
                    },
                    {
                        name: '2.4.1 Bypass Blocks',
                        test: () => this.testBypassBlocks(),
                        guideline: 'Skip links or headings allow bypassing repeated content'
                    },
                    {
                        name: '2.4.2 Page Titled',
                        test: () => this.testPageTitled(),
                        guideline: 'Web pages have descriptive titles'
                    },
                    {
                        name: '3.1.1 Language of Page',
                        test: () => this.testLanguageOfPage(),
                        guideline: 'Primary language of page is programmatically determinable'
                    },
                    {
                        name: '4.1.1 Parsing',
                        test: () => this.testParsing(),
                        guideline: 'Markup is valid and properly nested'
                    },
                    {
                        name: '4.1.2 Name, Role, Value',
                        test: () => this.testNameRoleValue(),
                        guideline: 'UI components have accessible names, roles, and values'
                    }
                ];

                for (const test of tests) {
                    try {
                        const result = await test.test();
                        this.results.wcag_a.push({
                            name: test.name,
                            guideline: test.guideline,
                            status: result.status,
                            message: result.message,
                            level: 'A'
                        });
                        this.totalTests++;
                        if (result.status === 'pass') this.passedTests++;
                    } catch (error) {
                        this.results.wcag_a.push({
                            name: test.name,
                            guideline: test.guideline,
                            status: 'fail',
                            message: `Error: ${error.message}`,
                            level: 'A'
                        });
                        this.totalTests++;
                    }
                }
            }

            async testWCAG_AA_Compliance() {
                console.log('Testing WCAG 2.1 Level AA compliance...');

                const tests = [
                    {
                        name: '1.4.3 Contrast (Minimum)',
                        test: () => this.testContrastMinimum(),
                        guideline: 'Text has contrast ratio of at least 4.5:1'
                    },
                    {
                        name: '1.4.4 Resize Text',
                        test: () => this.testResizeText(),
                        guideline: 'Text can be resized up to 200% without loss of functionality'
                    },
                    {
                        name: '1.4.5 Images of Text',
                        test: () => this.testImagesOfText(),
                        guideline: 'Images of text are avoided when possible'
                    },
                    {
                        name: '2.4.6 Headings and Labels',
                        test: () => this.testHeadingsAndLabels(),
                        guideline: 'Headings and labels are descriptive'
                    },
                    {
                        name: '2.4.7 Focus Visible',
                        test: () => this.testFocusVisible(),
                        guideline: 'Keyboard focus indicator is visible'
                    },
                    {
                        name: '3.1.2 Language of Parts',
                        test: () => this.testLanguageOfParts(),
                        guideline: 'Language changes are programmatically determinable'
                    },
                    {
                        name: '3.2.1 On Focus',
                        test: () => this.testOnFocus(),
                        guideline: 'Focus does not trigger unexpected context changes'
                    },
                    {
                        name: '3.2.2 On Input',
                        test: () => this.testOnInput(),
                        guideline: 'Input does not trigger unexpected context changes'
                    }
                ];

                for (const test of tests) {
                    try {
                        const result = await test.test();
                        this.results.wcag_aa.push({
                            name: test.name,
                            guideline: test.guideline,
                            status: result.status,
                            message: result.message,
                            level: 'AA'
                        });
                        this.totalTests++;
                        if (result.status === 'pass') this.passedTests++;
                    } catch (error) {
                        this.results.wcag_aa.push({
                            name: test.name,
                            guideline: test.guideline,
                            status: 'fail',
                            message: `Error: ${error.message}`,
                            level: 'AA'
                        });
                        this.totalTests++;
                    }
                }
            }

            async testWCAG_AAA_Compliance() {
                console.log('Testing WCAG 2.1 Level AAA compliance...');

                const tests = [
                    {
                        name: '1.4.6 Contrast (Enhanced)',
                        test: () => this.testContrastEnhanced(),
                        guideline: 'Text has contrast ratio of at least 7:1'
                    },
                    {
                        name: '2.4.9 Link Purpose (Link Only)',
                        test: () => this.testLinkPurpose(),
                        guideline: 'Link purpose is clear from link text alone'
                    },
                    {
                        name: '2.4.10 Section Headings',
                        test: () => this.testSectionHeadings(),
                        guideline: 'Section headings organize content'
                    },
                    {
                        name: '3.2.5 Change on Request',
                        test: () => this.testChangeOnRequest(),
                        guideline: 'Context changes only occur on user request'
                    }
                ];

                for (const test of tests) {
                    try {
                        const result = await test.test();
                        this.results.wcag_aaa.push({
                            name: test.name,
                            guideline: test.guideline,
                            status: result.status,
                            message: result.message,
                            level: 'AAA'
                        });
                        this.totalTests++;
                        if (result.status === 'pass') this.passedTests++;
                    } catch (error) {
                        this.results.wcag_aaa.push({
                            name: test.name,
                            guideline: test.guideline,
                            status: 'fail',
                            message: `Error: ${error.message}`,
                            level: 'AAA'
                        });
                        this.totalTests++;
                    }
                }
            }
        }

        // Initialize and run tests when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            const tester = new AccessibilityComplianceTester();
            await tester.runAllTests();
        });
    </script>
</body>
</html>  
  <script>
        // Accessibility test implementations
        class AccessibilityComplianceTester {
            // ... (previous constructor and main methods)

            // WCAG A Level Tests
            testNonTextContent() {
                const images = document.querySelectorAll('img');
                const decorativeImages = document.querySelectorAll('img[alt=""], img[role="presentation"]');
                const imagesWithAlt = document.querySelectorAll('img[alt]:not([alt=""])');
                
                const totalImages = images.length;
                const properImages = decorativeImages.length + imagesWithAlt.length;
                
                return {
                    status: totalImages === properImages ? 'pass' : 'fail',
                    message: `${properImages}/${totalImages} images have proper alt text or are marked decorative`
                };
            }

            testInfoAndRelationships() {
                const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
                const labels = document.querySelectorAll('label');
                const inputs = document.querySelectorAll('input, select, textarea');
                const ariaLabels = document.querySelectorAll('[aria-label], [aria-labelledby]');
                
                let score = 0;
                let total = 0;
                
                // Check heading hierarchy
                if (headings.length > 0) {
                    score++;
                    total++;
                }
                
                // Check form labels
                inputs.forEach(input => {
                    total++;
                    if (input.labels && input.labels.length > 0 || 
                        input.hasAttribute('aria-label') || 
                        input.hasAttribute('aria-labelledby')) {
                        score++;
                    }
                });
                
                return {
                    status: score === total ? 'pass' : score > total * 0.8 ? 'warn' : 'fail',
                    message: `${score}/${total} elements have proper relationships`
                };
            }

            testMeaningfulSequence() {
                const tabbableElements = this.getTabbableElements();
                const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
                
                // Check if headings follow logical order
                let headingOrderCorrect = true;
                let previousLevel = 0;
                
                headings.forEach(heading => {
                    const level = parseInt(heading.tagName.charAt(1));
                    if (level > previousLevel + 1) {
                        headingOrderCorrect = false;
                    }
                    previousLevel = level;
                });
                
                return {
                    status: headingOrderCorrect && tabbableElements.length > 0 ? 'pass' : 'warn',
                    message: `Heading hierarchy: ${headingOrderCorrect ? 'correct' : 'issues found'}, Tab order: ${tabbableElements.length} elements`
                };
            }

            testUseOfColor() {
                // Check if error states, required fields, etc. use more than just color
                const requiredFields = document.querySelectorAll('[required]');
                const errorElements = document.querySelectorAll('.error, [aria-invalid="true"]');
                
                let colorOnlyCount = 0;
                let totalIndicators = requiredFields.length + errorElements.length;
                
                // This is a simplified test - in practice would need more sophisticated analysis
                return {
                    status: colorOnlyCount === 0 ? 'pass' : 'fail',
                    message: `${totalIndicators} status indicators found, ${colorOnlyCount} rely only on color`
                };
            }

            testKeyboardAccess() {
                const interactiveElements = document.querySelectorAll(
                    'button, a[href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );
                
                let accessibleCount = 0;
                interactiveElements.forEach(element => {
                    if (element.tabIndex >= 0 || element.tagName === 'BUTTON' || element.tagName === 'A') {
                        accessibleCount++;
                    }
                });
                
                return {
                    status: accessibleCount === interactiveElements.length ? 'pass' : 'fail',
                    message: `${accessibleCount}/${interactiveElements.length} interactive elements are keyboard accessible`
                };
            }

            testNoKeyboardTrap() {
                // Simulate keyboard navigation to check for traps
                const tabbableElements = this.getTabbableElements();
                
                if (tabbableElements.length === 0) {
                    return { status: 'warn', message: 'No tabbable elements found' };
                }
                
                // Basic test - in practice would need actual keyboard simulation
                return {
                    status: 'pass',
                    message: `${tabbableElements.length} tabbable elements, no obvious keyboard traps detected`
                };
            }

            testBypassBlocks() {
                const skipLinks = document.querySelectorAll('a[href^="#"]');
                const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
                const landmarks = document.querySelectorAll('[role="main"], [role="navigation"], [role="banner"], main, nav, header');
                
                const bypassMechanisms = skipLinks.length + (headings.length > 0 ? 1 : 0) + landmarks.length;
                
                return {
                    status: bypassMechanisms > 0 ? 'pass' : 'fail',
                    message: `${bypassMechanisms} bypass mechanisms found (skip links: ${skipLinks.length}, headings: ${headings.length > 0 ? 'yes' : 'no'}, landmarks: ${landmarks.length})`
                };
            }

            testPageTitled() {
                const title = document.title;
                return {
                    status: title && title.trim().length > 0 ? 'pass' : 'fail',
                    message: title ? `Page title: "${title}"` : 'No page title found'
                };
            }

            testLanguageOfPage() {
                const htmlLang = document.documentElement.lang;
                return {
                    status: htmlLang && htmlLang.trim().length > 0 ? 'pass' : 'fail',
                    message: htmlLang ? `Page language: ${htmlLang}` : 'No language attribute on html element'
                };
            }

            testParsing() {
                // Basic HTML validation checks
                const duplicateIds = this.findDuplicateIds();
                const unclosedTags = this.findUnclosedTags();
                
                return {
                    status: duplicateIds.length === 0 && unclosedTags.length === 0 ? 'pass' : 'fail',
                    message: `Duplicate IDs: ${duplicateIds.length}, Unclosed tags: ${unclosedTags.length}`
                };
            }

            testNameRoleValue() {
                const formControls = document.querySelectorAll('input, select, textarea, button');
                let properlyLabeled = 0;
                
                formControls.forEach(control => {
                    if (control.hasAttribute('aria-label') || 
                        control.hasAttribute('aria-labelledby') ||
                        (control.labels && control.labels.length > 0) ||
                        control.textContent.trim().length > 0) {
                        properlyLabeled++;
                    }
                });
                
                return {
                    status: properlyLabeled === formControls.length ? 'pass' : 'fail',
                    message: `${properlyLabeled}/${formControls.length} form controls have accessible names`
                };
            }

            // WCAG AA Level Tests
            testContrastMinimum() {
                // This would require color analysis - simplified implementation
                const textElements = document.querySelectorAll('p, span, div, button, a, h1, h2, h3, h4, h5, h6');
                let contrastIssues = 0;
                
                // In a real implementation, you'd calculate actual contrast ratios
                // For now, we'll do a basic check for obviously problematic combinations
                
                return {
                    status: contrastIssues === 0 ? 'pass' : 'fail',
                    message: `${contrastIssues} potential contrast issues found (manual verification recommended)`
                };
            }

            testResizeText() {
                // Test if text can be resized (basic check)
                const body = document.body;
                const originalFontSize = window.getComputedStyle(body).fontSize;
                
                return {
                    status: 'pass',
                    message: `Base font size: ${originalFontSize} (zoom functionality depends on browser)`
                };
            }

            testImagesOfText() {
                const images = document.querySelectorAll('img');
                let textImages = 0;
                
                images.forEach(img => {
                    if (img.alt && /text|word|letter|font/i.test(img.alt)) {
                        textImages++;
                    }
                });
                
                return {
                    status: textImages === 0 ? 'pass' : 'warn',
                    message: `${textImages} potential images of text found`
                };
            }

            testHeadingsAndLabels() {
                const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
                const labels = document.querySelectorAll('label');
                
                let descriptiveHeadings = 0;
                let descriptiveLabels = 0;
                
                headings.forEach(heading => {
                    if (heading.textContent.trim().length > 3) {
                        descriptiveHeadings++;
                    }
                });
                
                labels.forEach(label => {
                    if (label.textContent.trim().length > 2) {
                        descriptiveLabels++;
                    }
                });
                
                return {
                    status: descriptiveHeadings === headings.length && descriptiveLabels === labels.length ? 'pass' : 'warn',
                    message: `Descriptive headings: ${descriptiveHeadings}/${headings.length}, labels: ${descriptiveLabels}/${labels.length}`
                };
            }

            testFocusVisible() {
                const focusableElements = this.getTabbableElements();
                let visibleFocusCount = 0;
                
                focusableElements.forEach(element => {
                    const styles = window.getComputedStyle(element, ':focus');
                    if (styles.outline !== 'none' || styles.boxShadow !== 'none') {
                        visibleFocusCount++;
                    }
                });
                
                return {
                    status: visibleFocusCount > 0 ? 'pass' : 'warn',
                    message: `${visibleFocusCount}/${focusableElements.length} elements have visible focus indicators`
                };
            }

            // Helper methods
            getTabbableElements() {
                return Array.from(document.querySelectorAll(
                    'button:not([disabled]), a[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
                ));
            }

            findDuplicateIds() {
                const ids = {};
                const duplicates = [];
                
                document.querySelectorAll('[id]').forEach(element => {
                    const id = element.id;
                    if (ids[id]) {
                        duplicates.push(id);
                    } else {
                        ids[id] = true;
                    }
                });
                
                return duplicates;
            }

            findUnclosedTags() {
                // Simplified check - in practice would need proper HTML parsing
                return [];
            }

            displayResults() {
                this.displayResultSection('wcag-a-results', this.results.wcag_a, 'WCAG 2.1 Level A');
                this.displayResultSection('wcag-aa-results', this.results.wcag_aa, 'WCAG 2.1 Level AA');
                this.displayResultSection('wcag-aaa-results', this.results.wcag_aaa, 'WCAG 2.1 Level AAA');
                
                this.updateComplianceScore();
            }

            displayResultSection(containerId, results, sectionName) {
                const container = document.getElementById(containerId);
                if (!container) return;

                let html = '';
                results.forEach(result => {
                    const statusClass = `test-${result.status}`;
                    const statusIcon = result.status === 'pass' ? '‚úÖ' : result.status === 'warn' ? '‚ö†Ô∏è' : '‚ùå';
                    html += `
                        <div class="test-result ${statusClass}">
                            ${statusIcon} <strong>${result.name}</strong>
                            <span class="wcag-level wcag-${result.level.toLowerCase()}">${result.level}</span>
                            <br>
                            <small>${result.guideline}</small>
                            <br>
                            <em>${result.message}</em>
                        </div>
                    `;
                });

                container.innerHTML = html;
            }

            updateComplianceScore() {
                const scoreElement = document.getElementById('score-value');
                const scoreContainer = document.getElementById('compliance-score');
                
                if (this.totalTests === 0) {
                    scoreElement.textContent = 'No tests run';
                    return;
                }
                
                const score = Math.round((this.passedTests / this.totalTests) * 100);
                scoreElement.textContent = `${score}%`;
                
                // Update styling based on score
                scoreContainer.className = 'compliance-score ';
                if (score >= 90) {
                    scoreContainer.className += 'score-excellent';
                } else if (score >= 70) {
                    scoreContainer.className += 'score-good';
                } else {
                    scoreContainer.className += 'score-poor';
                }
            }

            generateAuditSummary() {
                const summaryContainer = document.getElementById('audit-summary');
                const score = Math.round((this.passedTests / this.totalTests) * 100);
                
                let recommendations = [];
                if (score < 90) {
                    recommendations.push('Review failed tests and implement fixes');
                }
                if (score < 70) {
                    recommendations.push('Consider accessibility audit by expert');
                    recommendations.push('Implement comprehensive accessibility testing');
                }
                
                const html = `
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h3>Test Results</h3>
                            <div>Total Tests: ${this.totalTests}</div>
                            <div class="test-pass">‚úÖ Passed: ${this.passedTests}</div>
                            <div class="test-fail">‚ùå Failed: ${this.totalTests - this.passedTests}</div>
                            <div><strong>Score: ${score}%</strong></div>
                        </div>
                        <div class="feature-card">
                            <h3>Compliance Level</h3>
                            <div>${score >= 90 ? 'üèÜ Excellent' : score >= 70 ? '‚úÖ Good' : '‚ö†Ô∏è Needs Improvement'}</div>
                            <div><strong>Recommendations:</strong></div>
                            ${recommendations.map(rec => `<div>‚Ä¢ ${rec}</div>`).join('')}
                        </div>
                    </div>
                `;
                
                summaryContainer.innerHTML = html;
            }
        }

        // Auto-run tests when page loads
        document.addEventListener('DOMContentLoaded', async () => {
            const tester = new AccessibilityComplianceTester();
            await tester.runAllTests();
        });
    </script>